#!/usr/bin/python

# Library for MicroPi V2
# Developed by: SB Components & Hypersmart
# Project: micro:Pi

import RPi.GPIO as GPIO
import pigpio
from rpi_ws281x import PixelStrip, Color
# from board import SCL, SDA
# import busio2 as busio
# from oled_text import OledText
import Adafruit_SSD1306
from PIL import Image, ImageDraw, ImageFont
import subprocess
import argparse
import time
from time import sleep

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)


class Motor:

    # Class to handle interaction with the motor pins
    # Supports redefinition of "forward" and "backward" depending on how motors
    # are connected
    # Use the supplied Motorshieldtest module to test the correct configuration
    # for your project.
    # Arguments:
    # motor = string motor pin label (i.e. "MOTOR1","MOTOR2","MOTOR3","MOTOR4")
    # identifying the pins to which the motor is connected.
    # config = int defines which pins control "forward" and "backward" movement

    motorpins = {"MOTOR4": {"config": {1: {"e": 12, "f": 8, "r": 7}, 2: {"e": 12, "f": 7, "r": 8}}, "arrow": 1},
                 "MOTOR3": {"config": {1: {"e": 21, "f": 9, "r": 11}, 2: {"e": 21, "f": 11, "r": 9}}, "arrow": 2},
                 "MOTOR2": {"config": {1: {"e": 25, "f": 24, "r": 23}, 2: {"e": 25, "f": 23, "r": 24}}, "arrow": 3},
                 "MOTOR1": {"config": {1: {"e": 17, "f": 22, "r": 27}, 2: {"e": 17, "f": 27, "r": 22}}, "arrow": 4}}

    def __init__(self, motor, config):

        self.testMode = False
        self.pins = self.motorpins[motor]["config"][config]
        GPIO.setup(self.pins['e'], GPIO.OUT)
        GPIO.setup(self.pins['f'], GPIO.OUT)
        GPIO.setup(self.pins['r'], GPIO.OUT)
        # 50 Hz frequency
        self.PWM = GPIO.PWM(self.pins['e'], 50)
        self.PWM.start(0)
        GPIO.output(self.pins['e'], GPIO.HIGH)
        GPIO.output(self.pins['f'], GPIO.LOW)
        GPIO.output(self.pins['r'], GPIO.LOW)

    def test(self, state):

        # Puts the motor into test mode
        # When in test mode the Arrow associated with the motor
        # receives power on "forward"
        # rather than the motor. Useful when testing your code.
        # Arguments:
        # state = boolean
        self.testMode = state

    def forward(self, speed):

        # Starts the motor turning in its configured "forward" direction.
        # Arguments:
        # speed = Duty Cycle Percentage from 0 to 100.
        # 0 - stop and 100 - maximum speed
        print("Forward")
        if self.testMode:
            print("arrow")
        else:
            self.PWM.ChangeDutyCycle(speed)
            GPIO.output(self.pins['f'], GPIO.HIGH)
            GPIO.output(self.pins['r'], GPIO.LOW)

    def reverse(self, speed):

        # Starts the motor turning in its configured "reverse" direction.
        # Arguments:
        # speed = Duty Cycle Percentage from 0 to 100.
        # 0 - stop and 100 - maximum speed
        print("Reverse")
        if self.testMode:
            print("Arrow")
        else:
            self.PWM.ChangeDutyCycle(speed)
            GPIO.output(self.pins['f'], GPIO.LOW)
            GPIO.output(self.pins['r'], GPIO.HIGH)

    def stop(self):

        # Stops power to the motor
        print("Stop")
        self.PWM.ChangeDutyCycle(0)
        GPIO.output(self.pins['f'], GPIO.LOW)
        GPIO.output(self.pins['r'], GPIO.LOW)

    def speed(self):

        # Control Speed of Motor
        pass


class LinkedMotors:

        # Links 2 or more motors together as a set.
        # This allows a single command to be used to control a
        # linked set of motors
        # e.g. For a 4x wheel vehicle this allows a single command
        # to make all 4 wheels go forward.
        # Starts the motor turning in its configured "forward" direction.
        # Arguments:
        # *motors = a list of Motor objects

    def __init__(self, *motors):

        self.motor = []
        for i in motors:
            print(i.pins)
            self.motor.append(i)

    def forward(self, speed):

        # Starts the motor turning in its configured "forward" direction.
        # Arguments:
        # speed = Duty Cycle Percentage from 0 to 100.
        # 0 - stop and 100 - maximum speed

        for i in range(len(self.motor)):
            self.motor[i].forward(speed)

    def reverse(self, speed):

        # Starts the motor turning in its configured "reverse" direction.
        # Arguments:
        # speed = Duty Cycle Percentage from 0 to 100.
        # 0 - stop and 100 - maximum speed

        for i in range(len(self.motor)):
            self.motor[i].reverse(speed)

    def stop(self):

        # Stops power to the motor

        for i in range(len(self.motor)):
            self.motor[i].stop()


class Stepper:

    # Defines stepper motor pins on the MotorShield
    # Arguments:
    # motor = stepper motor

    stepperpins = {"STEPPER1":{"en1": 17, "en2": 25, "c1": 27, "c2": 22, "c3": 24, "c4": 23},
                   "STEPPER2":{"en1": 21, "en2": 12, "c1": 9, "c2": 11, "c3": 8, "c4": 7}}

    def __init__(self, motor):
        self.config = self.stepperpins[motor]
        GPIO.output(self.config["en1"], GPIO.HIGH)
        GPIO.output(self.config["en2"], GPIO.HIGH)
        GPIO.output(self.config["c1"], GPIO.LOW)
        GPIO.output(self.config["c2"], GPIO.LOW)
        GPIO.output(self.config["c3"], GPIO.LOW)
        GPIO.output(self.config["c4"], GPIO.LOW)

        GPIO.output(self.config["en1"], GPIO.HIGH)
        GPIO.output(self.config["en2"], GPIO.HIGH)
        GPIO.output(self.config["c1"], GPIO.LOW)
        GPIO.output(self.config["c2"], GPIO.LOW)
        GPIO.output(self.config["c3"], GPIO.LOW)
        GPIO.output(self.config["c4"], GPIO.LOW)


    def setStep(self, w1, w2, w3, w4):

        # Set steps of Stepper Motor
        # Arguments
        # w1,w2,w3,w4 = Wire of Stepper Motor

        GPIO.output(self.config["c1"], w1)
        GPIO.output(self.config["c2"], w2)
        GPIO.output(self.config["c3"], w3)
        GPIO.output(self.config["c4"], w4)

    def forward(self, delay, steps):

        # Rotate Stepper motor in forward direction
        # delay = time between steps (milliseconds)                                                                                                                            Arguments:                                                                                                              delay = time between steps in miliseconds
        # steps = Number of Steps

        for i in range(0, steps):
            self.setStep(1, 0, 0, 0)
            time.sleep(delay)
            self.setStep(0, 1, 0, 0)
            time.sleep(delay)
            self.setStep(0, 0, 1, 0)
            time.sleep(delay)
            self.setStep(0, 0, 0, 1)
            time.sleep(delay)

    def backward(self, delay, steps):

        # Rotate Stepper motor in backward direction
        # Arguments:
        # delay = time between steps
        # steps = Number of Steps

        for i in range(0, steps):
            self.setStep(0, 0, 0, 1)
            time.sleep(delay)
            self.setStep(0, 0, 1, 0)
            time.sleep(delay)
            self.setStep(0, 1, 0, 0)
            time.sleep(delay)
            self.setStep(1, 0, 0, 0)
            time.sleep(delay)

    def stop(self):

        # Stops power to the motor

        print("Stop Stepper Motor")
        GPIO.output(self.config['c1'], GPIO.LOW)
        GPIO.output(self.config['c2'], GPIO.LOW)
        GPIO.output(self.config['c3'], GPIO.LOW)
        GPIO.output(self.config['c4'], GPIO.LOW)


class Sensor:

    # Defines a sensor connected to the sensor pins on the MotorShield
    # Arguments:
    # sensortype = string identifying which sensor is being configured.
    # i.e. "IR1", "IR2", "ULTRASONIC"
    # boundary = an integer specifying the minimum
    # distance at which the sensor
    # will return a Triggered response of True.

   s)
            self.motor.append(i)

    def forward(self, speed):

        # Starts the motor turning in its configured "forward" direction.
        # Arguments:
        # speed = Duty Cycle Percentage from 0 to 100.
        # 0 - stop and 100 - maximum speed

        for i in range(len(self.motor)):
            self.motor[i].forward(speed)

    def reverse(self, speed):

        # Starts the motor turning in its configured "reverse" direction.
        # Arguments:
        # speed = Duty Cycle Percentage from 0 to 100.
        # 0 - stop and 100 - maximum speed

        for i in range(len(self.motor)):
            self.motor[i].reverse(speed)

    def stop(self):

        # Stops power to the motor

        for i in range(len(self.motor)):
            self.motor[i].stop()


class Stepper:

    # Defines stepper motor pins on the MotorShield
    # Arguments:
    # motor = stepper motor

    stepperpins = {"STEPPER1":{"en1": 17, "en2": 25, "c1": 27, "c2": 22, "c3": 24, "c4": 23},
                   "STEPPER2":{"en1": 21, "en2": 12, "c1": 9, "c2": 11, "c3": 8, "c4": 7}}

    def __init__(self, motor):
        self.config = self.stepperpins[motor]
        GPIO.output(self.config["en1"], GPIO.HIGH)
        GPIO.output(self.config["en2"], GPIO.HIGH)
        GPIO.output(self.config["c1"], GPIO.LOW)
        GPIO.output(self.config["c2"], GPIO.LOW)
        GPIO.output(self.config["c3"], GPIO.LOW)
        GPIO.output(self.config["c4"], GPIO.LOW)

        GPIO.output(self.config["en1"], GPIO.HIGH)
        GPIO.output(self.config["en2"], GPIO.HIGH)
        GPIO.output(self.config["c1"], GPIO.LOW)
        GPIO.output(self.config["c2"], GPIO.LOW)
        GPIO.output(self.config["c3"], GPIO.LOW)
        GPIO.output(self.config["c4"], GPIO.LOW)


    def setStep(self, w1, w2, w3, w4):

        # Set steps of Stepper Motor
        # Arguments
        # w1,w2,w3,w4 = Wire of Stepper Motor

        GPIO.output(self.config["c1"], w1)
        GPIO.output(self.config["c2"], w2)
        GPIO.output(self.config["c3"], w3)
        GPIO.output(self.config["c4"], w4)

    def forward(self, delay, steps):

        # Rotate Stepper motor in forward direction
        # delay = time between steps (milliseconds)                                                                                                                            Arguments:                                                                                                              delay = time between steps in miliseconds
        # steps = Number of Steps

        for i in range(0, steps):
            self.setStep(1, 0, 0, 0)
            time.sleep(delay)
            self.setStep(0, 1, 0, 0)
            time.sleep(delay)
            self.setStep(0, 0, 1, 0)
            time.sleep(delay)
            self.setStep(0, 0, 0, 1)
            time.sleep(delay)

    def backward(self, delay, steps):

        # Rotate Stepper motor in backward direction
        # Arguments:
        # delay = time between steps
        # steps = Number of Steps

        for i in range(0, steps):
            self.setStep(0, 0, 0, 1)
            time.sleep(delay)
            self.setStep(0, 0, 1, 0)
            time.sleep(delay)
            self.setStep(0, 1, 0, 0)
            time.sleep(delay)
            self.setStep(1, 0, 0, 0)
            time.sleep(delay)

    def stop(self):

        # Stops power to the motor

        print("Stop Stepper Motor")
        GPIO.output(self.config['c1'], GPIO.LOW)
        GPIO.output(self.config['c2'], GPIO.LOW)
        GPIO.output(self.config['c3'], GPIO.LOW)
        GPIO.output(self.config['c4'], GPIO.LOW)


class Sensor:

    # Defines a sensor connected to the sensor pins on the MotorShield
    # Arguments:
    # sensortype = string identifying which sensor is being configured.
    # i.e. "IR1", "IR2", "ULTRASONIC"
    # boundary = an integer specifying the minimum
    # distance at which the sensor
    # will return a Triggered response of True.

   